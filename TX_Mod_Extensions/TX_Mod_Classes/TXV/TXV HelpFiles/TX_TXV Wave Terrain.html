<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1138.47">
<style type="text/css">
p.p1 {margin: 8.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica; line-height: 18.0px}
</style>
</head>
<body>
<p class="p1"><b>TXV Wave Terrain</b></p>
<p class="p1">  </p>
<p class="p1">Properties: DrawSource Renders</p>
<p class="p1">  </p>
<p class="p1"><i>See also: </i><A href="TX_TXV System.html">TXV System<A></p>
<p class="p1"><br></p>
<p class="p1"><b><i>Introduction:</i></b></p>
<p class="p1">This module generates an image based on a "wave terrain", a mathematically generated model of a landscape (seen from above) which is colored based on the height of the land.</p>
<p class="p1">The model uses up to 4 layers of mathematical functions (binary and unary processes) to create a terrain.
A range of X-axis and Y-axis values are passed as inputs to the functions, representing every pixel in the image.</p>
<p class="p1">Each layer has a selectable generative function - e.g. sin(x) - which can use numbers (constants) as well as X and Y position values to generate height values (Z-axis) for the terrain.</p>
<p class="p1">The layers can be joined in various possible combinations, and using various join processes to create the overall terrain.</p>
<p class="p1">Finally, to create the image, color is added to the terrain based on the height of each pixel.</p>
<p class="p1"><br></p>
<p class="p1"><b><i>Controls:</i></b></p>
<p class="p1"><br></p>
<p class="p1"><b><i>Terrain Button</i></b></p>
<p class="p1"><b>terrainStructure</b> - index (def: 0, range: 0 : 10) options: <b> [0]</b>_1L (A), <b> [1]</b>_1L (B), <b> [2]</b>_1L (C), <b> [3]</b>_1L (D), <b> [4]</b>_2L (A:B), <b> [5]</b>_3L ((A:B) : C), <b> [6]</b>_3L (A : (B:C)), <b> [7]</b>_4L (((A:B) : C) : D), <b> [8]</b>_4L ((A:B) : (C:D)), <b> [9]</b>_4L ((A : (B:C)) : D), <b> [10]</b>_4L (A : (B : (C:D))). </p>
<p class="p1"><b>layerABJoinProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>layerBCJoinProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>layerCDJoinProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>outputRangeProcess</b> - index (def: 0, range: 0 : 2) options: <b> [0]</b>_Fold, <b> [1]</b>_Wrap, <b> [2]</b>_Clip. </p>
<p class="p1"><b>outputRangeMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>outputRangeMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>coloringMethod</b> - index (def: 0, range: 0 : 20) options: <b> [0]</b>_Use color1/2/3 with colorMixCurve to blend, <b> [1]</b>_Use color1/2/3 with linear blend, <b> [2]</b>_Use color1/2 with colorMixCurve to blend, <b> [3]</b>_Use color1/2 with linear blend, <b> [4]</b>_Use color2/3 with colorMixCurve to blend, <b> [5]</b>_Use color2/3 with linear blend, <b> [6]</b>_Use Black/Grey/White with colorMixCurve to blend, <b> [7]</b>_Use Black/Grey/White with linear blend, <b> [8]</b>_Use White/Black/White with colorMixCurve to blend, <b> [9]</b>_Use White/Black/White with linear blend, <b> [10]</b>_Use Black/White/Black with colorMixCurve to blend, <b> [11]</b>_Use Black/White/Black with linear blend, <b> [12]</b>_Use Blue/Black/Red with colorMixCurve to blend, <b> [13]</b>_Use Blue/Black/Red with linear blend, <b> [14]</b>_Use Color Curves as HSBA with colorMixCurve to blend, <b> [15]</b>_Use Color Curves as HSBA with linear blend, <b> [16]</b>_Use Color Curves as RGBA with colorMixCurve to blend, <b> [17]</b>_Use Color Curves as RGBA with linear blend, <b> [16]</b>_Use Color Curves as HSLA with colorMixCurve to blend, <b> [17]</b>_Use Color Curves as HSLA with linear blend. </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Squeeze & Skew Button</i></b></p>
<p class="p1"><b>squeezeX</b> - float with modulation (def: 0, range: -1 : 1). </p>
<p class="p1"><b>squeezeY</b> - float with modulation (def: 0, range: -1 : 1). </p>
<p class="p1"><b>skewX</b> - float with modulation (def: 0, range: -1 : 1). </p>
<p class="p1"><b>skewY</b> - float with modulation (def: 0, range: -1 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer A :: Layer Button</i></b></p>
<p class="p1"><b>layerA_usePolarCoords</b> - switch (def: 0). </p>
<p class="p1"><b>layerA_rotate</b> - float with modulation (def: 0, range: -360 : 360). </p>
<p class="p1"><b>layerA_inputXMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_inputXMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_inputYMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_inputYMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcs12InSeries</b> - switch (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer A :: Offset 1 Button</i></b></p>
<p class="p1"><b>layerA_offsetProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerA_offsetProcess1Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerA_offsetProcess1MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess1AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess1MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess1MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess1AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess1MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer A :: Offset 2 Button</i></b></p>
<p class="p1"><b>layerA_offsetProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerA_offsetProcess2Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerA_offsetProcess2MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess2AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess2MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess2MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess2AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_offsetProcess2MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer A :: Generate Button</i></b></p>
<p class="p1"><b>layerA_generatorProcessType</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerA_genInputXYProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>layerA_genInputXMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_genInputXPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerA_genInputYMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_genInputYPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerA_genInputMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerA_genInputOffset</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer A :: Post Process Button</i></b></p>
<p class="p1"><b>layerA_postProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerA_postProcess1Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerA_postProcess1YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_postProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerA_postProcess2Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerA_postProcess2YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerA_postProcess3Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerA_postProcess3Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerA_postProcess3YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer B :: Layer Button</i></b></p>
<p class="p1"><b>layerB_usePolarCoords</b> - switch (def: 0). </p>
<p class="p1"><b>layerB_rotate</b> - float with modulation (def: 0, range: -360 : 360). </p>
<p class="p1"><b>layerB_inputXMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_inputXMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_inputYMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_inputYMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcs12InSeries</b> - switch (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer B :: Offset 1 Button</i></b></p>
<p class="p1"><b>layerB_offsetProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerB_offsetProcess1Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerB_offsetProcess1MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess1AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess1MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess1MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess1AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess1MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer B :: Offset 2 Button</i></b></p>
<p class="p1"><b>layerB_offsetProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerB_offsetProcess2Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerB_offsetProcess2MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess2AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess2MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess2MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess2AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_offsetProcess2MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer B :: Generate Button</i></b></p>
<p class="p1"><b>layerB_generatorProcessType</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerB_genInputXYProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>layerB_genInputXMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_genInputXPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerB_genInputYMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_genInputYPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerB_genInputMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerB_genInputOffset</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer B :: Post Process Button</i></b></p>
<p class="p1"><b>layerB_postProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerB_postProcess1Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerB_postProcess1YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_postProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerB_postProcess2Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerB_postProcess2YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerB_postProcess3Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerB_postProcess3Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerB_postProcess3YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer C :: Layer Button</i></b></p>
<p class="p1"><b>layerC_usePolarCoords</b> - switch (def: 0). </p>
<p class="p1"><b>layerC_rotate</b> - float with modulation (def: 0, range: -360 : 360). </p>
<p class="p1"><b>layerC_inputXMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_inputXMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_inputYMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_inputYMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcs12InSeries</b> - switch (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer C :: Offset 1 Button</i></b></p>
<p class="p1"><b>layerC_offsetProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerC_offsetProcess1Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerC_offsetProcess1MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess1AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess1MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess1MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess1AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess1MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer C :: Offset 2 Button</i></b></p>
<p class="p1"><b>layerC_offsetProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerC_offsetProcess2Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerC_offsetProcess2MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess2AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess2MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess2MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess2AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_offsetProcess2MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer C :: Generate Button</i></b></p>
<p class="p1"><b>layerC_generatorProcessType</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerC_genInputXYProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>layerC_genInputXMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_genInputXPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerC_genInputYMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_genInputYPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerC_genInputMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerC_genInputOffset</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer C :: Post Process Button</i></b></p>
<p class="p1"><b>layerC_postProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerC_postProcess1Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerC_postProcess1YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_postProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerC_postProcess2Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerC_postProcess2YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerC_postProcess3Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerC_postProcess3Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerC_postProcess3YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer D :: Layer Button</i></b></p>
<p class="p1"><b>layerD_usePolarCoords</b> - switch (def: 0). </p>
<p class="p1"><b>layerD_rotate</b> - float with modulation (def: 0, range: -360 : 360). </p>
<p class="p1"><b>layerD_inputXMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_inputXMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_inputYMin</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_inputYMax</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcs12InSeries</b> - switch (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer D :: Offset 1 Button</i></b></p>
<p class="p1"><b>layerD_offsetProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerD_offsetProcess1Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerD_offsetProcess1MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess1AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess1MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess1MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess1AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess1MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer D :: Offset 2 Button</i></b></p>
<p class="p1"><b>layerD_offsetProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerD_offsetProcess2Type</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerD_offsetProcess2MultInputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess2AddInputX</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess2MultOutputX</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess2MultInputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess2AddInputY</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_offsetProcess2MultOutputY</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer D :: Generate Button</i></b></p>
<p class="p1"><b>layerD_generatorProcessType</b> - index (def: 0, range: 0 : 55) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1). </p>
<p class="p1"><b>layerD_genInputXYProcess</b> - index (def: 0, range: 0 : 48) options: <b> [0]</b>_x + y, <b> [1]</b>_x - y, <b> [2]</b>_y - x, <b> [3]</b>_x * y, <b> [4]</b>_x / y, <b> [5]</b>_y / x, <b> [6]</b>_x % y, <b> [7]</b>_y % x, <b> [8]</b>_min(x, y), <b> [9]</b>_max(x, y), <b> [10]</b>_pow(abs(x), y), <b> [11]</b>_pow(abs(y), x), <b> [12]</b>_int(x == y) [0 or 1], <b> [13]</b>_int(x != y) [0 or 1], <b> [14]</b>_int(x > y) [0 or 1], <b> [15]</b>_int(x < y) [0 or 1], <b> [16]</b>_int(x >= y) [0 or 1], <b> [17]</b>_int(x <= y) [0 or 1], <b> [18]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [19]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [20]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [21]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [22]</b>_distance(x, y) [distance between x and y], <b> [23]</b>_perlinNoise(x, y) [smooth noise], <b> [24]</b>_perlinNoise(y, x) [smooth noise], <b> [25]</b>_atan(x/y), <b> [26]</b>_atan(y/x), <b> [27]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [28]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [29]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [30]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [31]</b>_fold(x, y) [fold x from 0 to y], <b> [32]</b>_fold(y, x) [fold y from 0 to x], <b> [33]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [34]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [35]</b>_wrap(x, y) [wrap x from 0 to y], <b> [36]</b>_wrap(y, x) [wrap y from 0 to x], <b> [37]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [38]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [39]</b>_round(x, y) [round x to multiple of y], <b> [40]</b>_round(y, x) [round y to multiple of x], <b> [41]</b>_roundUp(x, y) [round up x to multiple of y], <b> [42]</b>_roundUp(y, x) [round up y to multiple of x], <b> [43]</b>_trunc(x, y) [truncate x to multiple of y], <b> [44]</b>_trunc(y, x) [truncate y to multiple of x], <b> [45]</b>_thresh(x, y), <b> [46]</b>_thresh(y, x), <b> [47]</b>_x [y ignored], <b> [48]</b>_y [x ignored]. </p>
<p class="p1"><b>layerD_genInputXMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_genInputXPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerD_genInputYMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_genInputYPower</b> - integer with modulation (def: 1, range: 0 : 100). </p>
<p class="p1"><b>layerD_genInputMult</b> - float with modulation (def: 1, range: -100 : 100). </p>
<p class="p1"><b>layerD_genInputOffset</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Layer D :: Post Process Button</i></b></p>
<p class="p1"><b>layerD_postProcess1Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerD_postProcess1Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerD_postProcess1YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_postProcess2Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerD_postProcess2Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerD_postProcess2YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><b>layerD_postProcess3Active</b> - switch (def: 0). </p>
<p class="p1"><b>layerD_postProcess3Type</b> - index (def: 0, range: 0 : 104) options: <b> [0]</b>_x, <b> [1]</b>_-x, <b> [2]</b>_abs(x), <b> [3]</b>_sign(x) [1 or 0 or -1], <b> [4]</b>_(1 / x), <b> [5]</b>_sin(2*pi * x), <b> [6]</b>_cos(2*pi * x), <b> [7]</b>_tan(2*pi * x), <b> [8]</b>_asin(x) * 2/pi, <b> [9]</b>_acos(x) * 2/pi, <b> [10]</b>_atan(x) * 2/pi, <b> [11]</b>_noise1(x) [smooth noise between -1 and 1], <b> [12]</b>_abs(noise1(x)) [smooth noise between -1 and 1], <b> [13]</b>_fract(x), <b> [14]</b>_ceil(x), <b> [15]</b>_floor(x), <b> [16]</b>_squared(x), <b> [17]</b>_cubed(x), <b> [18]</b>_sqrt(abs(x)), <b> [19]</b>_1 / sqrt(abs(x)), <b> [20]</b>_exp(abs(x)), <b> [21]</b>_exp2(x) - 2 to the power x, <b> [22]</b>_log(x), <b> [23]</b>_log2(x), <b> [24]</b>_step(0.5, x) [0 if x < 0.5, otherwise 1], <b> [25]</b>_step(0, x) [0 if x < 0, otherwise 1], <b> [26]</b>_clamp(x, 0, 1) [clamp x from 0 to 1], <b> [27]</b>_clamp(x, -1, 1) [clamp x to +/-1], <b> [28]</b>_fold(x, 0, 1) [fold x from 0 to 1], <b> [29]</b>_fold(x, -1, 1) [bilateral fold x to +/-1], <b> [30]</b>_wrap(x, 0, 1) [wrap x from 0 to 1], <b> [31]</b>_wrap(x, -1, 1) [bilateral wrap x to +/-1], <b> [32]</b>_lookup curve 1 unipolar clamp(x, 0, 1), <b> [33]</b>_lookup curve 1 bipolar clamp(x, -1, 1), <b> [34]</b>_lookup curve 1 unipolar fold(x, 0, 1), <b> [35]</b>_lookup curve 1 bipolar fold(x, -1, 1), <b> [36]</b>_lookup curve 1 unipolar wrap(x, 0, 1), <b> [37]</b>_lookup curve 1 bipolar wrap(x, -1, 1), <b> [38]</b>_lookup curve 2 unipolar clamp(x, 0, 1), <b> [39]</b>_lookup curve 2 bipolar clamp(x, -1, 1), <b> [40]</b>_lookup curve 2 unipolar fold(x, 0, 1), <b> [41]</b>_lookup curve 2 bipolar fold(x, -1, 1), <b> [42]</b>_lookup curve 2 unipolar wrap(x, 0, 1), <b> [43]</b>_lookup curve 2 bipolar wrap(x, -1, 1), <b> [44]</b>_lookup curve 3 unipolar clamp(x, 0, 1), <b> [45]</b>_lookup curve 3 bipolar clamp(x, -1, 1), <b> [46]</b>_lookup curve 3 unipolar fold(x, 0, 1), <b> [47]</b>_lookup curve 3 bipolar fold(x, -1, 1), <b> [48]</b>_lookup curve 3 unipolar wrap(x, 0, 1), <b> [49]</b>_lookup curve 3 bipolar wrap(x, -1, 1), <b> [50]</b>_lookup curve 4 unipolar clamp(x, 0, 1), <b> [51]</b>_lookup curve 4 bipolar clamp(x, -1, 1), <b> [52]</b>_lookup curve 4 unipolar fold(x, 0, 1), <b> [53]</b>_lookup curve 4 bipolar fold(x, -1, 1), <b> [54]</b>_lookup curve 4 unipolar wrap(x, 0, 1), <b> [55]</b>_lookup curve 4 bipolar wrap(x, -1, 1), <b> [56]</b>_x + y, <b> [57]</b>_x - y, <b> [58]</b>_y - x, <b> [59]</b>_x * y, <b> [60]</b>_x / y, <b> [61]</b>_y / x, <b> [62]</b>_x % y, <b> [63]</b>_y % x, <b> [64]</b>_min(x, y), <b> [65]</b>_max(x, y), <b> [66]</b>_pow(abs(x), y), <b> [67]</b>_pow(abs(y), x), <b> [68]</b>_int(x == y) [0 or 1], <b> [69]</b>_int(x != y) [0 or 1], <b> [70]</b>_int(x > y) [0 or 1], <b> [71]</b>_int(x < y) [0 or 1], <b> [72]</b>_int(x >= y) [0 or 1], <b> [73]</b>_int(x <= y) [0 or 1], <b> [74]</b>_step(x, y) [0 if y<x, otherwise 1], <b> [75]</b>_step(y, x) [0 if x<y, otherwise 1], <b> [76]</b>_smoothstep(-x, x, y) [0 if y <= -x, smoothed for y between -x and x, otherwise 1], <b> [77]</b>_smoothstep(-y, y, x) [0 if x <= y-, smoothed for x between -y and y, otherwise 1], <b> [78]</b>_distance(x, y) [distance between x and y], <b> [79]</b>_perlinNoise(x, y) [smooth noise], <b> [80]</b>_perlinNoise(y, x) [smooth noise], <b> [81]</b>_atan(x/y), <b> [82]</b>_atan(y/x), <b> [83]</b>_clamp(x, 0, y) [clamp x from 0 to y], <b> [84]</b>_clamp(y, 0, x) [clamp y from 0 to x], <b> [85]</b>_clamp2(x, -y, y) [bilateral clamp x to +/-y], <b> [86]</b>_clamp2(y, -x, x) [bilateral clamp y to +/-x], <b> [87]</b>_fold(x, y) [fold x from 0 to y], <b> [88]</b>_fold(y, x) [fold y from 0 to x], <b> [89]</b>_fold2(x, y) [bilateral fold x to +/-y], <b> [90]</b>_fold2(y, x) [bilateral fold y to +/-x], <b> [91]</b>_wrap(x, y) [wrap x from 0 to y], <b> [92]</b>_wrap(y, x) [wrap y from 0 to x], <b> [93]</b>_wrap2(x, y) [bilateral wrap x to +/-y], <b> [94]</b>_wrap2(y, x) [bilateral wrap y to +/-x], <b> [95]</b>_round(x, y) [round x to multiple of y], <b> [96]</b>_round(y, x) [round y to multiple of x], <b> [97]</b>_roundUp(x, y) [round up x to multiple of y], <b> [98]</b>_roundUp(y, x) [round up y to multiple of x], <b> [99]</b>_trunc(x, y) [truncate x to multiple of y], <b> [100]</b>_trunc(y, x) [truncate y to multiple of x], <b> [101]</b>_thresh(x, y), <b> [102]</b>_thresh(y, x), <b> [103]</b>_x [y ignored], <b> [104]</b>_y [x ignored]. </p>
<p class="p1"><b>layerD_postProcess3YVal</b> - float with modulation (def: 0, range: -100 : 100). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Lookup Curves :: Curve 1 Button</i></b></p>
<p class="p1"><b>lookupCurve1A</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve1B</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve1Morph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>lookupCurve1Phase</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Lookup Curves :: Curve 2 Button</i></b></p>
<p class="p1"><b>lookupCurve2A</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve2B</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve2Morph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>lookupCurve2Phase</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Lookup Curves :: Curve 3 Button</i></b></p>
<p class="p1"><b>lookupCurve3A</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve3B</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve3Morph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>lookupCurve3Phase</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Lookup Curves :: Curve 4 Button</i></b></p>
<p class="p1"><b>lookupCurve4A</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve4B</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>lookupCurve4Morph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>lookupCurve4Phase</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Perlin Button</i></b></p>
<p class="p1"><b>perlinLayer1Mix</b> - float with modulation (def: 0.533, range: 0 : 1). </p>
<p class="p1"><b>perlinLayer2Mix</b> - float with modulation (def: 0.267, range: 0 : 1). </p>
<p class="p1"><b>perlinLayer3Mix</b> - float with modulation (def: 0.133, range: 0 : 1). </p>
<p class="p1"><b>perlinLayer4Mix</b> - float with modulation (def: 0.067, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Color 1 Button</i></b></p>
<p class="p1"><b>color1Hue</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>color1HueRotate</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>color1Saturation</b> - float with modulation (def: 0.6, range: 0 : 1). </p>
<p class="p1"><b>color1Brightness</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>color1Alpha</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><b>color1HSBAsRGB</b> - switch with modulation (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Color 2 Button</i></b></p>
<p class="p1"><b>color2Hue</b> - float with modulation (def: 0.25, range: 0 : 1). </p>
<p class="p1"><b>color2HueRotate</b> - float with modulation (def: 0.25, range: 0 : 1). </p>
<p class="p1"><b>color2Saturation</b> - float with modulation (def: 0.6, range: 0 : 1). </p>
<p class="p1"><b>color2Brightness</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>color2Alpha</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><b>color2HSBAsRGB</b> - switch with modulation (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Color 3 Button</i></b></p>
<p class="p1"><b>color3Hue</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>color3HueRotate</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>color3Saturation</b> - float with modulation (def: 0.6, range: 0 : 1). </p>
<p class="p1"><b>color3Brightness</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>color3Alpha</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><b>color3HSBAsRGB</b> - switch with modulation (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Hue Curve Button</i></b></p>
<p class="p1"><b>colorHueCurveA</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorHueCurveB</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorHueCurveMorph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>colorHueCurveRotate</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Saturation Curve Button</i></b></p>
<p class="p1"><b>colorSaturationCurveA</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorSaturationCurveB</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorSaturationCurveMorph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Brightness Curve Button</i></b></p>
<p class="p1"><b>colorBrightnessCurveA</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorBrightnessCurveB</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorBrightnessCurveMorph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Colors :: Alpha Curve Button</i></b></p>
<p class="p1"><b>colorAlphaCurveA</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorAlphaCurveB</b> - drawable curve (size: 256 points). </p>
<p class="p1"><b>colorAlphaCurveMorph</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Clear & Render Button</i></b></p>
<p class="p1"><b>renderContinuosly</b> - switch with modulation (def: 1). </p>
<p class="p1"><b>renderNow</b> - switch with modulation (def: 0). </p>
<p class="p1"><b>clearBeforeRender</b> - switch with modulation (def: 1). </p>
<p class="p1"><b>clearNow</b> - switch with modulation (def: 0). </p>
<p class="p1"><b>clearColorHue</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>clearColorSaturation</b> - float with modulation (def: 0.6, range: 0 : 1). </p>
<p class="p1"><b>clearColorBrightness</b> - float with modulation (def: 0, range: 0 : 1). </p>
<p class="p1"><b>clearColorAlpha</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><b>clearColorHSBAsRGB</b> - switch with modulation (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Draw :: Active, Size, Alpha Button</i></b></p>
<p class="p1"><b>drawActive</b> - switch with modulation (def: 1). </p>
<p class="p1"><b>maxWidthHeightRule</b> - index (def: 0, range: 0 : 5) options: <b> [0]</b>_Use Screen Width & Height, <b> [1]</b>_Square - Use Max of Screen Width & Height, <b> [2]</b>_Square - Use Min of Screen Width & Height, <b> [3]</b>_Square - Use Screen Width, <b> [4]</b>_Square - Use Screen Height, <b> [5]</b>_Use Custom Size. </p>
<p class="p1"><b>customMaxWidth</b> - integer (def: 1024, range: 1 : 4096). </p>
<p class="p1"><b>customMaxHeight</b> - integer (def: 768, range: 1 : 4096). </p>
<p class="p1"><b>drawAlpha</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><b>drawWidth</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><b>drawHeight</b> - float with modulation (def: 1, range: 0 : 1). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Draw :: Scale Button</i></b></p>
<p class="p1"><b>scaleX</b> - float with modulation (def: 1, range: -10 : 10). </p>
<p class="p1"><b>scaleY</b> - float with modulation (def: 1, range: -10 : 10). </p>
<p class="p1"><b>useScaleXForScaleY</b> - switch (def: 0). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Draw :: Position, Anchor, Rotate Button</i></b></p>
<p class="p1"><b>drawPosX</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>drawPosY</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>anchorX</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>anchorY</b> - float with modulation (def: 0.5, range: 0 : 1). </p>
<p class="p1"><b>rotate</b> - float with modulation (def: 0, range: -360 : 360). </p>
<p class="p1"><b>rotateMultiply</b> - float with modulation (def: 1, range: 0 : 10). </p>
<p class="p1"><br></p>
<p class="p1"><b><i>Modulation Inputs:</i></b></p>
<p class="p1"><b>drawActive</b></p>
<p class="p1"><b>squeezeX</b></p>
<p class="p1"><b>squeezeY</b></p>
<p class="p1"><b>skewX</b></p>
<p class="p1"><b>skewY</b></p>
<p class="p1"><b>outputRangeMin</b></p>
<p class="p1"><b>outputRangeMax</b></p>
<p class="p1"><b>lookupCurve1Morph</b></p>
<p class="p1"><b>lookupCurve1Phase</b></p>
<p class="p1"><b>lookupCurve2Morph</b></p>
<p class="p1"><b>lookupCurve2Phase</b></p>
<p class="p1"><b>lookupCurve3Morph</b></p>
<p class="p1"><b>lookupCurve3Phase</b></p>
<p class="p1"><b>lookupCurve4Morph</b></p>
<p class="p1"><b>lookupCurve4Phase</b></p>
<p class="p1"><b>perlinLayer1Mix</b></p>
<p class="p1"><b>perlinLayer2Mix</b></p>
<p class="p1"><b>perlinLayer3Mix</b></p>
<p class="p1"><b>perlinLayer4Mix</b></p>
<p class="p1"><b>color1Hue</b></p>
<p class="p1"><b>color1HueRotate</b></p>
<p class="p1"><b>color1Saturation</b></p>
<p class="p1"><b>color1Brightness</b></p>
<p class="p1"><b>color1Alpha</b></p>
<p class="p1"><b>color1HSBAsRGB</b></p>
<p class="p1"><b>color2Hue</b></p>
<p class="p1"><b>color2HueRotate</b></p>
<p class="p1"><b>color2Saturation</b></p>
<p class="p1"><b>color2Brightness</b></p>
<p class="p1"><b>color2Alpha</b></p>
<p class="p1"><b>color2HSBAsRGB</b></p>
<p class="p1"><b>color3Hue</b></p>
<p class="p1"><b>color3HueRotate</b></p>
<p class="p1"><b>color3Saturation</b></p>
<p class="p1"><b>color3Brightness</b></p>
<p class="p1"><b>color3Alpha</b></p>
<p class="p1"><b>color3HSBAsRGB</b></p>
<p class="p1"><b>colorHueCurveMorph</b></p>
<p class="p1"><b>colorHueCurveRotate</b></p>
<p class="p1"><b>colorSaturationCurveMorph</b></p>
<p class="p1"><b>colorBrightnessCurveMorph</b></p>
<p class="p1"><b>colorAlphaCurveMorph</b></p>
<p class="p1"><b>layerA_rotate</b></p>
<p class="p1"><b>layerA_inputXMin</b></p>
<p class="p1"><b>layerA_inputXMax</b></p>
<p class="p1"><b>layerA_inputYMin</b></p>
<p class="p1"><b>layerA_inputYMax</b></p>
<p class="p1"><b>layerA_offsetProcess1MultInputX</b></p>
<p class="p1"><b>layerA_offsetProcess1AddInputX</b></p>
<p class="p1"><b>layerA_offsetProcess1MultOutputX</b></p>
<p class="p1"><b>layerA_offsetProcess1MultInputY</b></p>
<p class="p1"><b>layerA_offsetProcess1AddInputY</b></p>
<p class="p1"><b>layerA_offsetProcess1MultOutputY</b></p>
<p class="p1"><b>layerA_offsetProcess2MultInputX</b></p>
<p class="p1"><b>layerA_offsetProcess2AddInputX</b></p>
<p class="p1"><b>layerA_offsetProcess2MultOutputX</b></p>
<p class="p1"><b>layerA_offsetProcess2MultInputY</b></p>
<p class="p1"><b>layerA_offsetProcess2AddInputY</b></p>
<p class="p1"><b>layerA_offsetProcess2MultOutputY</b></p>
<p class="p1"><b>layerA_genInputXMult</b></p>
<p class="p1"><b>layerA_genInputXPower</b></p>
<p class="p1"><b>layerA_genInputYMult</b></p>
<p class="p1"><b>layerA_genInputYPower</b></p>
<p class="p1"><b>layerA_genInputMult</b></p>
<p class="p1"><b>layerA_genInputOffset</b></p>
<p class="p1"><b>layerA_postProcess1YVal</b></p>
<p class="p1"><b>layerA_postProcess2YVal</b></p>
<p class="p1"><b>layerA_postProcess3YVal</b></p>
<p class="p1"><b>layerB_rotate</b></p>
<p class="p1"><b>layerB_inputXMin</b></p>
<p class="p1"><b>layerB_inputXMax</b></p>
<p class="p1"><b>layerB_inputYMin</b></p>
<p class="p1"><b>layerB_inputYMax</b></p>
<p class="p1"><b>layerB_offsetProcess1MultInputX</b></p>
<p class="p1"><b>layerB_offsetProcess1AddInputX</b></p>
<p class="p1"><b>layerB_offsetProcess1MultOutputX</b></p>
<p class="p1"><b>layerB_offsetProcess1MultInputY</b></p>
<p class="p1"><b>layerB_offsetProcess1AddInputY</b></p>
<p class="p1"><b>layerB_offsetProcess1MultOutputY</b></p>
<p class="p1"><b>layerB_offsetProcess2MultInputX</b></p>
<p class="p1"><b>layerB_offsetProcess2AddInputX</b></p>
<p class="p1"><b>layerB_offsetProcess2MultOutputX</b></p>
<p class="p1"><b>layerB_offsetProcess2MultInputY</b></p>
<p class="p1"><b>layerB_offsetProcess2AddInputY</b></p>
<p class="p1"><b>layerB_offsetProcess2MultOutputY</b></p>
<p class="p1"><b>layerB_genInputXMult</b></p>
<p class="p1"><b>layerB_genInputXPower</b></p>
<p class="p1"><b>layerB_genInputYMult</b></p>
<p class="p1"><b>layerB_genInputYPower</b></p>
<p class="p1"><b>layerB_genInputMult</b></p>
<p class="p1"><b>layerB_genInputOffset</b></p>
<p class="p1"><b>layerB_postProcess1YVal</b></p>
<p class="p1"><b>layerB_postProcess2YVal</b></p>
<p class="p1"><b>layerB_postProcess3YVal</b></p>
<p class="p1"><b>layerC_rotate</b></p>
<p class="p1"><b>layerC_inputXMin</b></p>
<p class="p1"><b>layerC_inputXMax</b></p>
<p class="p1"><b>layerC_inputYMin</b></p>
<p class="p1"><b>layerC_inputYMax</b></p>
<p class="p1"><b>layerC_offsetProcess1MultInputX</b></p>
<p class="p1"><b>layerC_offsetProcess1AddInputX</b></p>
<p class="p1"><b>layerC_offsetProcess1MultOutputX</b></p>
<p class="p1"><b>layerC_offsetProcess1MultInputY</b></p>
<p class="p1"><b>layerC_offsetProcess1AddInputY</b></p>
<p class="p1"><b>layerC_offsetProcess1MultOutputY</b></p>
<p class="p1"><b>layerC_offsetProcess2MultInputX</b></p>
<p class="p1"><b>layerC_offsetProcess2AddInputX</b></p>
<p class="p1"><b>layerC_offsetProcess2MultOutputX</b></p>
<p class="p1"><b>layerC_offsetProcess2MultInputY</b></p>
<p class="p1"><b>layerC_offsetProcess2AddInputY</b></p>
<p class="p1"><b>layerC_offsetProcess2MultOutputY</b></p>
<p class="p1"><b>layerC_genInputXMult</b></p>
<p class="p1"><b>layerC_genInputXPower</b></p>
<p class="p1"><b>layerC_genInputYMult</b></p>
<p class="p1"><b>layerC_genInputYPower</b></p>
<p class="p1"><b>layerC_genInputMult</b></p>
<p class="p1"><b>layerC_genInputOffset</b></p>
<p class="p1"><b>layerC_postProcess1YVal</b></p>
<p class="p1"><b>layerC_postProcess2YVal</b></p>
<p class="p1"><b>layerC_postProcess3YVal</b></p>
<p class="p1"><b>layerD_rotate</b></p>
<p class="p1"><b>layerD_inputXMin</b></p>
<p class="p1"><b>layerD_inputXMax</b></p>
<p class="p1"><b>layerD_inputYMin</b></p>
<p class="p1"><b>layerD_inputYMax</b></p>
<p class="p1"><b>layerD_offsetProcess1MultInputX</b></p>
<p class="p1"><b>layerD_offsetProcess1AddInputX</b></p>
<p class="p1"><b>layerD_offsetProcess1MultOutputX</b></p>
<p class="p1"><b>layerD_offsetProcess1MultInputY</b></p>
<p class="p1"><b>layerD_offsetProcess1AddInputY</b></p>
<p class="p1"><b>layerD_offsetProcess1MultOutputY</b></p>
<p class="p1"><b>layerD_offsetProcess2MultInputX</b></p>
<p class="p1"><b>layerD_offsetProcess2AddInputX</b></p>
<p class="p1"><b>layerD_offsetProcess2MultOutputX</b></p>
<p class="p1"><b>layerD_offsetProcess2MultInputY</b></p>
<p class="p1"><b>layerD_offsetProcess2AddInputY</b></p>
<p class="p1"><b>layerD_offsetProcess2MultOutputY</b></p>
<p class="p1"><b>layerD_genInputXMult</b></p>
<p class="p1"><b>layerD_genInputXPower</b></p>
<p class="p1"><b>layerD_genInputYMult</b></p>
<p class="p1"><b>layerD_genInputYPower</b></p>
<p class="p1"><b>layerD_genInputMult</b></p>
<p class="p1"><b>layerD_genInputOffset</b></p>
<p class="p1"><b>layerD_postProcess1YVal</b></p>
<p class="p1"><b>layerD_postProcess2YVal</b></p>
<p class="p1"><b>layerD_postProcess3YVal</b></p>
<p class="p1"><b>renderContinuosly</b></p>
<p class="p1"><b>renderNow</b></p>
<p class="p1"><b>clearBeforeRender</b></p>
<p class="p1"><b>clearNow</b></p>
<p class="p1"><b>clearColorHue</b></p>
<p class="p1"><b>clearColorSaturation</b></p>
<p class="p1"><b>clearColorBrightness</b></p>
<p class="p1"><b>clearColorAlpha</b></p>
<p class="p1"><b>clearColorHSBAsRGB</b></p>
<p class="p1"><b>drawAlpha</b></p>
<p class="p1"><b>drawPosX</b></p>
<p class="p1"><b>drawPosY</b></p>
<p class="p1"><b>drawWidth</b></p>
<p class="p1"><b>drawHeight</b></p>
<p class="p1"><b>anchorX</b></p>
<p class="p1"><b>anchorY</b></p>
<p class="p1"><b>rotate</b></p>
<p class="p1"><b>rotateMultiply</b></p>
<p class="p1"><b>scaleX</b></p>
<p class="p1"><b>scaleY</b></p>
<p class="p1"><br></p>
</body>
</html>
